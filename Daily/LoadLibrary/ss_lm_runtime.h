/** 
*   @file       ss_lm_runtime.h
*   @brief      ?????????????????.  
*               ????????: slm_runtime.dll/slm_runtime_dev.dll 
*               ????????: slm_runtime_api.lib/slm_runtime_api_dev.lib 
*
*   ?????????????
*
*       ???????????slm_init???????????????
*       ???????????slm_login??????¬????????????????????????????????????
*       ?????????????????????????????slm_keepalive slm_encrypt slm_decrypt?????
*       ???????????slm_logout????????????????
*       ????????????????????slm_cleanup?????????????????????
*   @version   2.1.0
*   @date      2013-2020
*
*/
#ifndef __SS_LM_RUMTIME_H__
#define __SS_LM_RUMTIME_H__
#include "ss_define.h"
#include "ss_error.h"

#ifdef  _MSC_VER
#pragma comment(linker, "/defaultlib:ws2_32.lib")
#pragma comment(linker, "/defaultlib:iphlpapi.lib")
#pragma comment(linker, "/defaultlib:psapi.lib")
#pragma comment(linker, "/defaultlib:Shlwapi.lib")
#pragma comment(lib, "rpcrt4.lib")


#if _MSC_VER >= 1900   // 1900??VS2015????????????????VS2015?ñ???????????
#pragma comment(linker, "/defaultlib:legacy_stdio_definitions.lib")
#endif  // MSC_VER

#endif//???

/** ????????????????? */
#define LED_COLOR_BLUE      0
/** ????????????????? */
#define LED_COLOR_RED       1

/** ???????????????? */
#define LED_STATE_CLOSE     0
/** ??????????????? */
#define LED_STATE_OPEN      1
/** ???????????????? */
#define LED_STATE_SHRINK    2

/** Virbox??????? ????????????????????? SLM_CALLBACK_VERSION02 ) ??????lparam???–????? */
typedef SS_UINT32 (SSAPI *SS_CALL_BACK)(SS_UINT32   message,void*       wparam,void*       lparam);
    
//============================================================
//   Virbox??????? ?????? message ????
//============================================================
/** ????????????????? */
#define SS_ANTI_INFORMATION			0x0101
/** ??????????????????????wparam?????????????*/
#define SS_ANTI_WARNING				0x0102
/** ????????????? */
#define SS_ANTI_EXCEPTION			0x0103
/** ???????????????? */
#define SS_ANTI_IDLE				0x0104

/** ?????????????????? */
#define SS_MSG_SERVICE_START        0x0200
/** ???????????????? */
#define SS_MSG_SERVICE_STOP         0x0201
/** ????????????????????????? Virbox??????? ??????????????????????????wparam ???????? */
#define SS_MSG_LOCK_AVAILABLE       0x0202
/** ??????????????????????????????????wparam ???????? */
#define SS_MSG_LOCK_UNAVAILABLE     0x0203
/** ????????????????¬?????????wparam ???????¬??????–??? */
#define SS_MSG_CLOUD_USER_LOGIN     0x0204
/** ??????????????????????????wparam ??????????????–??? */
#define SS_MSG_CLOUD_USER_LOGOUT    0x0205

//============================================================
//   ???????????????????SS_ANTI_WARNING??? wparam ????
//============================================================
/** ?????????????????????????????????????????????????????????????? */
#define SS_ANTI_PATCH_INJECT		0x0201
/** ?????????????????????????????????¬??????hid.dll??lpk.dll????????????¬???? */
#define SS_ANTI_MODULE_INVALID		0x0202
/** ????????????????????????????Ollydbg??Windbg?????????????? */
#define SS_ANTI_ATTACH_FOUND		0x0203
/** ????????????????ë???????? */
#define SS_ANTI_THREAD_INVALID		0x0204
/** ????????????????????????????????????????????????? */
#define SS_ANTI_THREAD_ERROR		0x0205
/** ?????????????CRC???????????????????????????????????????”?????? */
#define SS_ANTI_CRC_ERROR			0x0206
/** ??????????????????????????????Ollydbg??Windbg */
#define SS_ANTI_DEBUGGER_FOUND		0x0207
//=============================================================

/** ????????????????? */
#define SLM_FIXTIME_RAND_LENGTH     8

/** SS_CALL_BACK??? ??????????API????????*/
#define SLM_CALLBACK_VERSION02      0x02

/** ????????????????*/
#define  SLM_MEM_MAX_SIZE           2048

/** ???????????????????????????? */
#define SLM_MAX_INPUT_SIZE          1758
/** ????????????????????????????? */
#define SLM_MAX_OUTPUT_SIZE         1758

/** ??????????????????????*/
#define SLM_MAX_USER_CRYPT_SIZE     1520

/** ?–??????????????????*/
#define SLM_MAX_USER_DATA_SIZE      2048

/** ?–????????????????????*/
#define SLM_MAX_WRITE_SIZE          1904

/** ????????????????????????????slm_sign_by_device */
#define SLM_VERIFY_DEVICE_PREFIX    "SENSELOCK"

/** ????????????????????????????slm_sign_by_device */
#define SLM_VERIFY_DATA_SIZE        41

/** ??????????????????????????*/
#define SLM_LOCK_SN_LENGTH          16

/** ??????ID???????????????*/
#define SLM_DEVELOPER_ID_SIZE       8

/** ?????¬?????????????????????????????*/
#define SLM_MAX_SERVER_NAME         32

/** ?????¬?????–?token?????????????*/
#define SLM_MAX_ACCESS_TOKEN_LENGTH 64

/** ?????¬??????????????????????????*/
#define SLM_MAX_CLOUD_SERVER_LENGTH 100

/** ?????????????????????????*/
#define SLM_SNIPPET_SEED_LENGTH     32

/** ??????API?????????????????*/
#define SLM_DEV_PASSWORD_LENGTH     16

/** ?–?GUID????????????? */
#define SLM_CLOUD_MAX_USER_GUID_SIZE 	        128	

/** ????GUID??????????? */
#define SLM_GUID_LENGTH 	                16	

/** ???????????????????????? */
#define SLM_FILE_TYPE_BINARY                    0
/** ???????????????????????????? */
#define SLM_FILE_TYPE_EXECUTIVE                 1
/** ??????????????????????? */
#define SLM_FILE_TYPE_KEY                       2

/** ????????????????????????? */
#define SLM_FILE_PRIVILEGE_FLAG_READ            0x01
/** ????????????????????????? */
#define SLM_FILE_PRIVILEGE_FLAG_WRITE           0x02
/** ???????????????????????????????????? */
#define SLM_FILE_PRIVILEGE_FLAG_USE             0x04
/** ??????????????????????????????? */
#define SLM_FILE_PRIVILEGE_FLAG_UPDATE          0x08

/** ???????????????????? */
#define SLM_FILE_PRIVILEGE_FLAG_ENTRY_READ      0x10
/** ??????????????????????? */
#define SLM_FILE_PRIVILEGE_FLAG_ENTRY_WRITE     0x20
/** ??????????????????????????????????*/
#define SLM_FILE_PRIVILEGE_FLAG_ENTRY_USE       0x40
/** ????????????????????????????? */
#define SLM_FILE_PRIVILEGE_FLAG_ENTRY_UPDATE    0x80



/** ?????¬?????????? */
#define SLM_LOGIN_MODE_AUTO						0x0000
/** ?????¬?????????¬?????? */
#define SLM_LOGIN_MODE_LOCAL_DONGLE				0x0001
/** ?????¬?????????¬?????? */
#define SLM_LOGIN_MODE_REMOTE_DONGLE			0x0002
/** ?????¬?????????¬???? */
#define SLM_LOGIN_MODE_CLOUD					0x0004
/** ?????¬?????????¬???????? */
#define SLM_LOGIN_MODE_LOCAL_SLOCK 				0x0008
/** ?????¬?????????¬??????? */
#define SLM_LOGIN_MODE_REMOTE_SLOCK				0x0010

/** ?????¬???????????????????????????????????????¬??????????????????????????????¬??????????“?????*/
#define SLM_LOGIN_FLAG_FIND_ALL         0x0001    
/** ?????¬????????????? */
#define SLM_LOGIN_FLAG_VERSION          0x0004
/** ?????¬??????????????????*/
#define SLM_LOGIN_FLAG_LOCKSN           0x0008
/** ?????¬?????????????? */
#define SLM_LOGIN_FLAG_SERVER           0x0010
/** ?????¬??????????????? */
#define SLM_LOGIN_FLAG_SNIPPET          0x0020


/** ????????????????????ID?????????? */
#define LANGUAGE_CHINESE_ASCII                  0x0001
/** ????????????????????ID????? */
#define LANGUAGE_ENGLISH_ASCII                  0x0002
/** ????????????????????ID?????????? */
#define LANGUAGE_TRADITIONAL_CHINESE_ASCII      0x0003

/** ??????????????????? Virbox??????? ??????? */
#define SLM_INIT_FLAG_NOTIFY            0x01

/** MAC ??????? */
#define SLM_MAC_SIZE                    6
/** CPU ???????? */
#define SLM_MAX_CPU_INFO_SIZE           128
/** BIOS ???????? */
#define SLM_MAX_BIOS_INFO_SIZE          128
/** Session ID ????????????? */
#define SLM_MAX_SESSION_ID_SIZE         32


/** ?????¬????????????????????????Virbox??????? ??????????????????????id???????0-N??? */
typedef unsigned int SLM_HANDLE_INDEX; 

/** ????????????”??  */
typedef enum _INFO_TYPE 
{
    /**  ??????????  */
    LOCK_INFO = 1,
    /**  ????????????? */
    SESSION_INFO = 2,
    /**  ?????¬????????? */
    LICENSE_INFO  = 3,
	/**  ?????????? */
	FILE_LIST  = 4
} INFO_TYPE;

/** ??????????????”??  */ 
typedef enum _LIC_USER_DATA_TYPE 
{
    /** ????? */
    ROM = 0,     
    /** ????? */
    RAW = 1,
    /** ?????? */
    PUB = 2
} LIC_USER_DATA_TYPE;

/** ??????????  */ 
typedef enum _ENUM_DESC_TYPE 
{
    ENUM_DESC_LOCAL_DONGLE = 0,
    ENUM_DESC_REMOTE_DONGLE = 1,
    ENUM_DESC_CLOUD = 2,
    ENUM_DESC_SMART_OFFLINE = 3,
    ENUM_DESC_LOCAL_SLOCK = 4,
	ENUM_DESC_REMOTE_SLOCK = 5,
} ENUM_DESV_TYPE;

/** ????????????? */
typedef struct _ST_LED_CONTROL 
{
    /**  0??????LED??1??????LED???????LEX_COLOR_XXX  */
    SS_UINT32   index;
    /**  0????????1???????? 2??????????????LED_STATE_XXX */
    SS_UINT32   state;
    /**  LED????????????????*/
    SS_UINT32   interval;   
} ST_LED_CONTROL;

/** ?????????   */
typedef struct _ST_INIT_PARAM 
{
    /** ??????????????????? SLM_CALLBACK_VERSION02 */
    SS_UINT32       version;
    /** ?????????? Virbox??????? ?????? SLM_INIT_FLAG_NOTIFY */
    SS_UINT32       flag;
    /** ??????????*/
    SS_CALL_BACK    pfn;
    /** ???????????????????????0???????????????7??*/
    SS_UINT32       timeout;
    /** API??????? VirboxLM ????????????https://developer.lm.virbox.com????????????????????????? */
    SS_BYTE         password[SLM_DEV_PASSWORD_LENGTH];
} ST_INIT_PARAM;

/** ????Login ?? */
typedef struct _ST_LOGIN_PARAM
{ 
    /** ????????????*/
    SS_UINT32       size;
    /** ???¬??????ID*/
    SS_UINT32       license_id;
    /** ???????????????????,??0???????????600??   */
    SS_UINT32       timeout;
    /** ?????¬????????????????????????????????????SLM_LOGIN_MODE_XXX)???????0???????SLM_LOGIN_MODE_AUTO*/
    SS_UINT32       login_mode;
    /** ?????¬????????SLM_LOGIN_FLAG_XXX??????????????????“???? */
    SS_UINT32       login_flag;
    /** ?????¬?????????????????????????????*/
    SS_BYTE         sn[SLM_LOCK_SN_LENGTH];
    /** ?????????????????????????????IP??? */
    SS_CHAR         server[SLM_MAX_SERVER_NAME];
    /** ?????–?token???????*/
    SS_CHAR         access_token[SLM_MAX_ACCESS_TOKEN_LENGTH];
    /** ????????????????????*/
    SS_CHAR         cloud_server[SLM_MAX_CLOUD_SERVER_LENGTH];
    /** ?????????????????????????????????,login_flag???????SLM_LOGIN_FLAG_SNIPPET*/
    SS_BYTE         snippet_seed[SLM_SNIPPET_SEED_LENGTH];
    /** ???¬?–??? guid ????????????? guid???????????????? */
    SS_CHAR         user_guid[SLM_CLOUD_MAX_USER_GUID_SIZE];
} ST_LOGIN_PARAM;

/** ???????  */
typedef struct _ST_LOCK_INFO 
{
    ///  ??????
    SS_UINT32           size;      
    ///  ???????0 = ????–?????2 = ????–???
    SS_UINT8            device_type;        
    ///  ?????, 0 = ????5?–???
    SS_UINT8            device_mode;    
    ///  ????
    SS_UINT16           res;             
    ///  Entry ????????–?????????
    SS_UINT8            lmfirm_version[4];  
    ///  H5 ??????????????????????????
    SS_UINT32           h5firm_version;   
    ///  ????????–?????????
    SS_UINT32           hardware_version;   
    ///  ?????????UTC??
    SS_UINT32           manufacture_date;   
    ///  ???????????????
    SS_UINT32           total_space;        
    ///  ??????????????
    SS_UINT32           available_space;    
    ///  ??????–?????????
    SS_UINT32           protocol;        
    ///  ?????????–?????????
    SS_UINT32           slave_addr;       
    ///  ????????UTC??
    SS_UINT32           clock;        
    ///  0 = ????????2 = ??????
    SS_UINT32           clock_type;    
    ///  ???????????????????????????????5??????????
    SS_UINT32           drop_times;        
    ///  ?????????????????
    SS_BYTE             lock_sn[SLM_LOCK_SN_LENGTH];  
    ///  ????????????–??????????????????????????
    SS_BYTE             user_info[128];     
    ///  ??????????????????
    SS_BYTE             inner_info[128];    
    ///  0 = ??????????1 = ??????
    SS_UINT32           shared_enabled;
    ///  ?????????????????????ID??
    SS_BYTE             owner_developer_id[SLM_DEVELOPER_ID_SIZE];
} ST_LOCK_INFO;

/** ?????????  */
typedef struct _ST_SESSION_INFO 
{
    ///  ??????
    SS_UINT32           size;            
    ///  ?????¬??????id 
    SS_UINT32           license_id;               
    union
    {
        SS_BYTE         sn[SLM_LOCK_SN_LENGTH];
        SS_BYTE         user_guid[SLM_GUID_LENGTH];
    };
    ///  ???????????? time_out
    SS_UINT32           app_time_out;        
    ///  ???????????? id
    SS_UINT32           app_process_id;      
    ///  ????MAC???
    SS_UINT8            mac[SLM_MAC_SIZE];      
    char                session_id[SLM_MAX_SESSION_ID_SIZE]; 
    ///  CPU ID Verndor ???
    char                cpuinfo[SLM_MAX_CPU_INFO_SIZE];  
    ///  BIOS??? ?????????   
    char                bios[SLM_MAX_BIOS_INFO_SIZE];     
} ST_SESSION_INFO;

/** ?????????  */
typedef struct _ST_SLM_LICENSE_INFO
{
    ///  ??????
    SS_UINT32   size;
    ///  ???????
    SS_UINT32   lic_ver;  
    ///  ??????????????????flag??????
    SS_BYTE     flag[4];        
    ///  ?????guid
    SS_BYTE     guid[SLM_LOCK_SN_LENGTH];  
    ///  ????ID
    SS_UINT32   lic_id;    
    ///  ??????
    SS_UINT32   start_time;     
    ///  ??????
    SS_UINT32   end_time;   
    ///  ?????
    SS_UINT32   span_time;    
    ///  ????????
    SS_UINT32   time_stamp;     
    ///  ?????????
    SS_UINT16   serial;        
    ///  ???????????
    SS_UINT16   concurrency;    
    ///  ??????????
    SS_UINT32   count;         
    ///  ????????
    SS_UINT64   module_bit;    
    ///  ???????
    SS_UINT32   lock_time;      
    ///  ???????????
    SS_UINT32   first_use_time; 
    ///  ?????????
    SS_UINT32   curr_count;   
    ///  ?????????
    SS_UINT32   offline_period; 
    ///  ??????????????????????????????????????
    SS_UINT32   bind_node;      
    ///  ???????????????????????????????????????
    SS_UINT32   max_bind_node;  
    ///  ????????
    SS_UINT32   raw_size;   
    ///  ????????
    SS_UINT32   rom_size;   
    ///  ?????????
    SS_UINT32   pub_size;   
} ST_SLM_LICENSE_INFO;

/** ????????  */
typedef struct _ST_FILE_INFO 
{
    /** ?????????????????????????????????              */
    SS_BYTE     validate;                
    /** ???????????????                                 */
    SS_BYTE     type;                    
    /** ??????????                                       */
    SS_UINT16   pri;              
    /** ??????                                           */
    SS_UINT32   size;                  
    /** ?????????                                       */
    SS_UINT32   time;              
    /** ?????  ?????????????16???                     */
    SS_BYTE     name[16];                
} ST_FILE_INFO;

/** ???????????  */
typedef struct _ST_FILE_INFO_LIST
{
    /// ????1
    SS_UINT32       version;        
    SS_UINT32       count;
    ST_FILE_INFO    info[1];
} ST_FILE_INFO_LIST;

/** ???????  */
typedef struct _ST_DEV_INFO 
{
    ///	local, remote or cloud.(DESC type)
    SS_UINT16  		    desc_type;      
    ///  LM?????LM_FIRM_TYPE_XXX)
    SS_UINT16           firm_type;      
    SS_BYTE 	        developer_id[SLM_DEVELOPER_ID_SIZE];
    union 
    {
        struct 
        {
            SS_CHAR         cloud_server[114];
            SS_CHAR         user_token[48];
            // ??? user_guid ??¬?????????????????????????????????
            SS_BYTE         user_guid[SLM_GUID_LENGTH];
        } cloud, smart_offline;  //  ????/????????

        struct 
        {
            SS_BYTE         serial[SLM_LOCK_SN_LENGTH];
            SS_CHAR         ip[64];
            SS_UINT16       port;
            SS_CHAR         host_name[SLM_MAX_SERVER_NAME];
            //  reserved    
        } h5;  //  ?????

        struct 
        {
            // ??? user_guid ??¬????????????????????????????????
            SS_BYTE         user_guid[SLM_GUID_LENGTH]; 
            SS_CHAR         ip[64];
            SS_UINT16       port;
            //SS_BYTE         reserved[114 - 16 - 32];
            SS_CHAR         host_name[SLM_MAX_SERVER_NAME];
            // reserved for remote slock
            // ??????????????????SC0009000000595??????????209-6BU-MGP????
            SS_CHAR         account_name[64];
        } slock;  //  ????
    };

} ST_DEV_INFO;

/** ????????  */
typedef struct _ST_ENUM_DEVICE 
{
    ST_DEV_INFO     dev_info;
    ST_LOCK_INFO    lock_info;
} ST_ENUM_DEVICE;

/** ????????  */
typedef struct _ST_DEV_INFO_LIST
{
    SS_UINT32       version;        // ????1
    SS_UINT32       count;
    ST_ENUM_DEVICE  info[1];
} ST_DEV_INFO_LIST;

/** ????id???  */
typedef struct _ST_LICENSE_IDS
{
    SS_UINT32       count;
    SS_UINT32       lic_ids[1];
} ST_LICENSE_IDS;

/** 
*   @defgroup RuntimeAPI  Virbox Runtime ??????
*   ??????? Virbox Runtime ?–?????????????????????????????????????????
*   @{
*/

#ifdef __cplusplus
extern "C" {
#endif

/*!
*   @brief      Runtime API ??????????????????? Runtime API ????????“????????????
*   @param[in]  pst_init    ????????????? #ST_INIT_PARAM ??????
*   @return     ???????SS_OK??????????????????
*   @remarks    #slm_init ?????? Virbox Runtime API ????????????????????? Virbox Runtime API ?????????????“??????
*               ??????????????? Runtime ??????????????????????????????
*               ????????
*                   ??????????????? Windows ???????????????? DllMain ????????? slm_init ?? slm_cleanup?????????????????????????£????????
*                   ?????????????????????????????????????????????????????????????????????????????????????????????
*                   ???? Windows ??¢??????? DllMain ???????????????????????????????????? Windows ??????????????????Linux ???æ? so ??
*                   ?????????????????????
*   @see        ST_INIT_PARAM slm_cleanup
*/
SS_UINT32 SSAPI slm_init(IN ST_INIT_PARAM* pst_init);

/*!
*   @brief      ???????????(????????????)
*   @param[in]  license_id      ??????????ID??0--0xFFFFFFFF??
*   @param[in]  format          ???????????? #INFO_FORMAT_TYPE ????????? #JSON ?? #STRUCT
*   @param[out] license_desc    ????????????????????? format ?????????? #slm_free ???
*   @return     ??????? SS_OK??????????????????
*   @remarks    ??????????????????????????????????????????????????? #slm_free ??? license_desc??
*               ?? format = #STRUCT ? license_desc ?????? ??? #ST_DEV_INFO_LIST
*   @see        INFO_FORMAT_TYPE
*/
SS_UINT32 SSAPI slm_find_license(
    IN  SS_UINT32           license_id,
    IN  INFO_FORMAT_TYPE    format,
    OUT char**              license_desc
    );


/*!
*   @brief      ”?????¬???–? token
*   @param[out] access_token    ????–??? token??????? #slm_free ???
*   @return     ??????? SS_OK????? oauth ???????ë?????????? SS_ERROR_BAD_CONNECT
*   @remarks    ??????????????? #slm_free ??? access_token
*/
SS_UINT32 SSAPI slm_get_cloud_token(OUT SS_CHAR** access_token);

/*!
*   @brief      ?????¬????,?? #JSON ???????,?????????????????????????????????????????????????
*               ???????????????????????????????????????????????????????????????????
*   @param[in]  license_param ??¬?????????????????????????? licenseid???????????¬??????
*   @param[in]  param_format  ??????????????????????? #STRUCT???????????SDK????2.1.0.15128?????????¬????????? json ??¬???????
*   @param[out] slm_handle    ?????¬?????????index?,????? 0-256 ???
*   @param[out] auth          ??? login ?????????????????? login ???????????????????????????????????????????????????????????¬?????????˜????? NULL??
*   @return     ??????? SS_OK??????????????????
*   @remarks
*   - #slm_login ????????????
*       -# ????????????????????????
*       -# ?? Runtime ????????????????????????????
*       -# ???????????????????????????????????????????????????????????????????
*       -# LM??????????????????????? RSA??????????ID?????????????????????
*       -# LM????????????? login ?????????????? ???????????????????
*   - ????????????
*       - ???????
*       -# ??? #ST_LOGIN_PARAM ?????????
*       -# #ST_LOGIN_PARAM::size         ????????????????????????????????????????????? SS_ERROR_RUNTIME_VERSION
*       -# #ST_LOGIN_PARAM::license_id   ????ID???32?????????????? 0-4294967295?????????
*       -# #ST_LOGIN_PARAM::login_mode   ?????¬????????????????????????????????????????????????
*       -# #ST_LOGIN_PARAM::sn           ?????¬???? ?????????????????16??????
*       -# #ST_LOGIN_PARAM::access_token ?????¬????????????????? oauth ????? access token
*       -# #ST_LOGIN_PARAM::timeout     ?????¬????? ????????????????????600????????????????????????????? 60s??????¢??? 12????12 * 60 * 60 ????
*       -# #ST_LOGIN_PARAM::user_guid    ??¬?–??? guid???????? #SLM_CLOUD_MAX_USER_GUID_SIZE???????? guid
*   @code
*		void test_normal()
*       {
*           SS_UINT32           status = SS_OK;
*           ST_INIT_PARAM       init_param = { SLM_CALLBACK_VERSION02, 0, 0, 20000 };
*           SLM_HANDLE_INDEX    slm_handle = 0;
*           ST_LOGIN_PARAM      login_param = { 0 };
*           
*           // psd??????????˜??????????????????????? VirboxLM ???????????????https://developer.lm.virbox.com
*           const char          psd[] = { 0xDB, 0x3B, 0x83, 0x8B, 0x2E, 0x4F, 0x08, 0xF5, 0xC9, 0xEF, 0xCD, 0x1A, 0x5D, 0xD1, 0x63, 0x41};
*
*           memcpy(init_param.password, psd, sizeof(init_param.password));  
*
*           status = slm_init(&init_param);
*           if(status != SS_OK)
*           {
*               return ;
*           }
*
*           login_param.license_id = 0;
*           login_param.size = sizeof(ST_LOGIN_PARAM);      // ????????????????????????????
*           login_param.login_mode = SLM_LOGIN_MODE_LOCAL;
*
*           status = slm_login(&login_param, STRUCT, &slm_handle, NULL);
*           if(status != SS_OK)
*           {
*               //todo do: deal error code
*               return ;
*           }
*
*           slm_logout(slm_handle);
*       }
*
*		void test_login_with_auth()
*		{
*			unsigned int sts = SS_OK;
*			ss_auth_xor_t auth = { 0 };
*			int key;
*		
*			typedef struct _ss_auth_xor_t
*			{
*				int size;		// ??????
*				int r[4];		// ?????????
*				int g[2];		// ??? 
*			} ss_auth_xor_t;
*
*			....
*			auth.size = sizeof(ss_auth_xor_t);
*			for (int i = 0; i != 4; ++i)
*				auth[i].r = rand();
*			key = (auth.r[0] + auth.r[1]) ^ (auth.r[2] + auth.r[3]);
*
*			sts = slm_login(&login, STRUCT, &slm_handle, &auth);
*			key = key ^ (auth.g[0] + auth.g[1]);
*			sts = (sts ^ key);
*			....
*		}
*   @endcode
*   @see slm_logout SS_UINT32 INFO_FORMAT_TYPE ST_LOGIN_PARAM
*/
SS_UINT32 SSAPI slm_login(
    IN  const ST_LOGIN_PARAM*  license_param,
    IN  INFO_FORMAT_TYPE       param_format,
    OUT SLM_HANDLE_INDEX *     slm_handle,
    IN OUT void*               auth
    );

/*!
*   @brief      ??????????????????????????
*   @param[in]  slm_handle    ??????????? #slm_login ???
*   @return     ??????? SS_OK??????????????????
*   @remarks    ????????????????????? #slm_logout ?????¬?????????????? Runtime ??????????????
*               ???????? Runtime ?????????256????¬??????????¬?????????????????????? 256 ????¬????????? Runtime ?????????????§??????¬???
*   @see        slm_login
*/
SS_UINT32 SSAPI slm_logout(SLM_HANDLE_INDEX slm_handle);

/*!
*   @brief      ?????¬??????????????????????????
*   @param[in]  slm_handle    ???????
*   @return     ??????? SS_OK??????????????????
*   @remarks    ?????????????????????????????slm_handle ???????????????? Runtime ??????????????
*   @code
*       DWORD WINAPI __stdcall _ThreadKeepalive(void *pVoid)
*       {
*           SLM_HANDLE_INDEX slm_handle = *(SLM_HANDLE_INDEX *)(pVoid);
*           SS_UINT32        status = SS_OK;
*
*           while (1)
*           {
*               status = slm_keep_alive(slm_handle);
*               if(status != SS_OK)
*               {
*                   //todo do: deal error code
*               }
*               Sleep(1000 * 10);      // ????????????????????????????????
*           }
*       }
*       
*       {
*           SS_UINT32           status = SS_OK;
*           SLM_HANDLE_INDEX    slm_handle = 0;
*           ST_LOGIN_PARAM      login_param = { 0 };
*           HANDLE hThread;
*           DWORD  id = 0;
*
*           login_param.license_id = 0;
*           login_param.size = sizeof(ST_LOGIN_PARAM);
*           login_param.login_mode = SLM_LOGIN_MODE_LOCAL;
*           login_param.time_out = 30;    // ???–??30???
*
*           status = slm_login(&login_param, STRUCT, &slm_handle, NULL);
*           if(status != SS_OK)
*           {
*               //todo do: deal error code
*               return ;
*           }
*
*           hThread = CreateThread(NULL, 0, _ThreadKeepalive, &slm_handle, 0, &id);
*           if (hThread == NULL)
*           {
*               //todo: deal error
*           }
*       }
*   @endcode
*   @see       slm_login
*/
SS_UINT32 SSAPI slm_keep_alive(SLM_HANDLE_INDEX slm_handle);

/*!
*   @brief      ?????????????????ID??????????????????
*   @param[in]  slm_handle   ??????????? #slm_login ???
*   @param[in]  inbuffer     ????????????,??? 16??? ???????????? 1520??????
*   @param[out] outbuffer    ?????????????,??? 16??? ???? 
*   @param[in]  len          ??????????????? 16 ??????????
*   @return     ??????? SS_OK??????????????????
*   @remarks    ??????????????????????????????????ë?????????¢??? 1520???????????????????????????????????
*               ??????????????????????????????????????????????????????            
*   @code
*       {
*           SS_UINT32   status = SS_OK;
*           SS_BYTE     plain[32] = { 0 };  // ????????AES??????????????????16??????
*           SS_BYTE     enc[32] = { 0 };
*           SS_BYTE     dec[32] = { 0 };
*
*           memcpy(data, "test data...", strlen("test data..."));
*
*           status = slm_encrypt(slm_handle, plain, enc, sizeof(enc));
*           if(status != SS_OK)
*           {
*               // todo: deal error code
*               return ;
*           }
*
*           status = slm_decrypt(slm_handle, enc, dec, sizeof(dec));
*           if(status != SS_OK)
*           {
*               // todo: deal error code
*               return ;
*           }
*
*           //???????????????????????
*           //if(plain == dec)
*           //{ 
*           //    SUCCESS;
*           //}
*           //else
*           //{
*           //    FAILURE;
*           //}
*       }
*   @endcode
*   @see        slm_encrypt slm_decrypt slm_login
 */
SS_UINT32 SSAPI slm_encrypt(
    IN  SLM_HANDLE_INDEX    slm_handle,
    IN  SS_BYTE*            inbuffer,
    OUT SS_BYTE*            outbuffer,
    IN  SS_UINT32           len
    );

/*!
*   @brief      ?????????????????ID??????????????????
*   @param[in]  slm_handle   ??????????? #slm_login ???
*   @param[in]  inbuffer     ????????????,??? 16??? ???????????? 1520??????
*   @param[out] outbuffer    ?????????????,??? 16??? ???? 
*   @param[in]  len          ??????????????? 16 ??????????
*   @return     ??????? SS_OK??????????????????
*   @remarks    ?????????? AES????????????????????????????????????????????????????–??????????????????????????????????????????
*               ??????????????????????????????????ë?????????¢??? 1520?????????????????????????????????????????????????????????
*               ???????????????????????????????????
*   @code
*       //see slm_encrypt
*   @endcode
*   @see        slm_encrypt slm_login
 */
SS_UINT32 SSAPI slm_decrypt(
    IN  SLM_HANDLE_INDEX    slm_handle, 
    IN  SS_BYTE*            inbuffer, 
    OUT SS_BYTE*            outbuffer, 
    IN  SS_UINT32           len
    );

/*!
*   @brief      ?????????–??????????
*   @param[in]  slm_handle ??????????? #slm_login ???
*   @param[in]  type       ?–???????????????????? LIC_USER_DATA_TYPE
*   @param[out] pmem_size  ?????–??????????
*   @return     ??????? SS_OK??????????????????
*   @see        LIC_USER_DATA_TYPE slm_user_data_getsize slm_user_data_read slm_user_data_write
 */
SS_UINT32 SSAPI slm_user_data_getsize(
    IN SLM_HANDLE_INDEX     slm_handle,
    IN LIC_USER_DATA_TYPE   type,
    OUT SS_UINT32*          pmem_size
    );

/*!
*   @brief      ????????????????? #PUB #RAW ?? #ROM
*   @param[in]  slm_handle   ??????????? #slm_login ???
*   @param[in]  type         ?–??????????????? #LIC_USER_DATA_TYPE
*   @param[out] readbuf      ?–????????????????
*   @param[in]  offset       ??????–????????????????
*   @param[in]  len          ????????????????
*   @return     ??????? SS_OK??????????????????
*   @remarks    ?????????????? 64k ?????????
*   @code
*       {        
*           SS_UINT32 size = 0;
*           SS_BYTE   *buff = 0;
*           SS_UINT32 status = SS_OK;
*       
*           status = slm_user_data_getsize(slm_handle, ROM, &size);   // ????????????
*           if (status == SS_OK && size > 0)
*           {
*               buff = (SS_BYTE *)calloc(sizeof(SS_BYTE), size);
*               status = slm_user_data_read(slm_handle, ROM, buff, 0, size);
*               if(status != SS_OK)
*               {
*                   // todo: deal error code
*               }
*               // ????????????????????????
*               free(buff);
*               buff = 0;
*           }
*       }
*   @endcode
*   @see        LIC_USER_DATA_TYPE slm_user_data_getsize slm_user_data_read slm_user_data_write
 */
SS_UINT32 SSAPI slm_user_data_read(
    IN  SLM_HANDLE_INDEX    slm_handle,
    IN  LIC_USER_DATA_TYPE  type,
    OUT SS_BYTE*            readbuf,
    IN  SS_UINT32           offset,
    IN  SS_UINT32           len
    );

/*!
*   @brief      ?????????????? ,???????????????????????????????????????? #slm_user_data_getsize ???
*   @param[in]  slm_handle      ??????????? #slm_login ???
*   @param[in]  writebuf        ????????????????
*   @param[in]  offset          ????????????????????????????????????????
*   @param[in]  len             ?????????????????????? = min(#slm_user_data_getsize, #SLM_MAX_WRITE_SIZE)
*   @return     ??????? SS_OK??????????????????
*   @remarks    ????????????????¢?????????????????????????????????????????????????????????
*               ????????????????????????? #SLM_MAX_WRITE_SIZE ???????????????????????
*   @code
*       {
*           SS_UINT32 size = 0;
*           SS_BYTE   write[20] = { "write data" };
*           SS_UINT32 status = SS_OK;
*           SS_UINT32 offset = 0
*
*           status = slm_user_data_getsize(slm_handle, RAW, &size);   // ????????????????
*           if (status == SS_OK && size > 0)
*           {
*               size = min( offset + sizeof(write), size);    // ?????????¢?????????????????
*               status = slm_user_data_write(slm_handle, write, offset, size);
*               if(status != SS_OK)
*               {
*                   // todo: deal error code
*               }
*           }
*       }
*   @endcode
*   @see       LIC_USER_DATA_TYPE   slm_user_data_getsize slm_user_data_read slm_user_data_write
 */
SS_UINT32 SSAPI slm_user_data_write(
    IN  SLM_HANDLE_INDEX    slm_handle,
    IN  SS_BYTE*            writebuf,
    IN  SS_UINT32           offset,
    IN  SS_UINT32           len
    );

/*!
*   @brief      ????????????????????????????????¬ 0??????
*   @param[in]  slm_handle    0??????????????????????????????????????????????? #slm_login ???
*   @param[in]  license_id    ??????????????? ????ID
*   @param[out] pmem_size     ?????????????
*   @return     ??????? SS_OK??????????????????
*   @remarks    ??????œ??–?????????¬?????????œ???????????????????????????????????????????????????????????
*               ????–???????????“????????????????????¬ 0?????????? 0?????? ????????????????? ????ID ?????????????????????????????
*               ???????? 0?????? ????????????Virbox ?????????????????????????? 0?????? ??????
*   @see        slm_user_data_read_pub 
*/
SS_UINT32 SSAPI slm_pub_data_getsize(
    IN  SLM_HANDLE_INDEX    slm_handle,
    IN  SS_UINT32           license_id,
    OUT SS_UINT32*          pmem_size
    );

/*!
*   @brief      ???????????????????¬ 0??????
*   @param[in]  slm_handle   0?????? ?????????????????????????????????????????? #slm_login ???
*   @param[in]  license_id   ??????????????? ????ID
*   @param[out] readbuf      ????????????????????????
*   @param[in]  offset       ???????????????????
*   @param[in]  len          ?????????????
*   @return     ??????? SS_OK??????????????????
*   @remarks    ??????œ??–?????????¬?????????œ???????????????????????????????????????????????????????????
*               ????–???????????“????????????????????¬ 0?????????? 0?????? ????????????????? ????ID ?????????????????????????????
*               ???????? 0?????? ????????????Virbox ?????????????????????????? 0?????? ??????
*   @code
*       {
*           SS_UINT32 size = 0;
*           SS_BYTE   *buff = 0;
*           SS_UINT32 status = SS_OK;
*           SS_UINT32 license_id = 1;   // ??????????????????ID
*
*           // ????????¬???????????? slm_login ?? code ???
*
*           status = slm_pub_data_getsize(slm_handle, license_id, &size);   // ????????????????????
*           if (status == SS_OK && size > 0)
*           {
*               buff = (SS_BYTE *)calloc(sizeof(SS_BYTE), size);
*               status = slm_user_data_read(slm_handle, license_id, buff, 0, size);
*               if(status != SS_OK)
*               {
*                   // todo: deal error code
*               }
*               // ???????????????????
*               free(buff);
*               buff = 0;
*           }
*       }
*   @endcode
*   @see        slm_user_data_pub_getsize 
*/
SS_UINT32 SSAPI slm_pub_data_read(
    IN  SLM_HANDLE_INDEX    slm_handle,
    IN  SS_UINT32           license_id,
    OUT SS_BYTE*            readbuf,
    IN  SS_UINT32           offset,
    IN  SS_UINT32           len
    );

/*!
*   @brief      ??????¬???????????????????????????????????
*   @param[in]  slm_handle  ??????????? #slm_login ???
*   @param[in]  type        ??????????? #INFO_TYPE
*   @param[in]  format      ??????????? #INFO_FORMAT_TYPE ?????????? #JSON ?? #STRUCT
*   @param[out] result      ?????????????????????????????? #slm_free ???
*   @return     ??????? SS_OK??????????????????
*   @remarks    ??????“???????????????¬??????????????????????????????????????????????????????????????????????
*   @code
*   // JSON ?????????
*   - type = LICENSE_INFO ??????????????????–????????????
*       {
*           "rom_size" :number(??????????
*           "raw_size" :number????????????
*           "pub_size" :number????????????
*           
*           "type": "local"/"remote"/"cloud"
*           "sn":"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
*           "guid":"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
*           "developer_id":   "xxxxxxxxxxxxxxxx"
*           "license_id":     number
*           "enable":         bool
*           "start_time":     number
*           "end_time":       number
*           "first_use_time": number
*           "span_time":      number
*           "counter":        number
*           "concurrent_type": "process" / "win_user_session"    // ????????
*           "concurrent":     number    //??????
*           "version":        number
*           "module":number
*           "last_update_timestamp":  number
*           "last_update_timesn":     number
*           "lock_time":      number     // ??????????????????????????????
*       }
*
*   - type = SESSION_INFO
*       {
*           "app_process_id":  number,
*           "app_time_out":    number,
*           "session_id":      ????????????
*           "bios": "BIOS information", ????????????
*           "cpuinfo": "CPU name", ????????????
*           "sn": ""(HEX16 String), ?????????????
*           "user_guid": ""(HEX16 String) ????????????
*           "mac":"00-00-00-00-00-00" ????????????
*       }
*    
*   - type = LOCK_INFO ????????????
*       {
*           "avaliable_space": number(Bytes),
*           "communication_protocol": number,
*           "lock_firmware_version": "0.0.0.0",
*           "lm_firmware_version": "1.1.1.1",
*           "h5_device_type": number,
*           "hardware_version": "2.2.2.2",
*           "manufacture_date": "2000-01-01 00:00:00",
*           "lock_sn": ""(HEX16 String),
*           "slave_addr": number,
*           "clock": number(UTC Time),
*           "user_info": ""(HEX16 String)(128???)
*           "inner_info": ""(HEX16 String)(128????
*       }
*   
*   - type = FILE_LIST
*       [
*        {
*           "validate":0,       (????????????????????)
*           "type":0,           (?????????????????=0??????????(evx)=1????????=2)
*           "privilege":0,      (?????????????????? 0xFF)
*           "size":123,         (????????????????)
*           "time":12345678,    (??????????UTC?????)
*           "name":"file1.evx"  (???????)
*        },
*        {...}
*       ]
*
*   // STRUCT ???????
*   - type = LICENSE_INFO
*      result ????? ST_SLM_LICENSE_INFO
*   - type = SESSION_INFO
*       result ????? ST_SESSION_INFO
*   - type = LOCK_INFO
*       result ????? ST_LOCK_INFO
*   - type = FILE_LIST
*       result ????? ST_FILE_INFO_LIST
*   @endcode
*   @see INFO_TYPE INFO_FORMAT_TYPE SLM_HANDLE_INDEX slm_login
*/
SS_UINT32 SSAPI slm_get_info(
    IN  SLM_HANDLE_INDEX	slm_handle,
    IN  INFO_TYPE			type,
    IN  INFO_FORMAT_TYPE	format,
    OUT char**              result
    );

/*!
*   @brief      ???????????????????????????????????????????????????????
*               ?????????? \link D2CAPI \endlink ????? #d2c_add_pkg ???????????????????????????????????????
*   @param[in]  slm_handle  ??????????? #slm_login ???
*   @param[in]  exfname     ?????????????????
*   @param[in]  inbuf       ??????????????????????????????
*   @param[in]  insize      ???????????(??????????????????? #SLM_MAX_INPUT_SIZE )
*   @param[out] poutbuf     ?????????????????????????????
*   @param[in]  outsize     ?????????
*   @param[out] pretsize    ???????????(??????????????????? #SLM_MAX_OUTPUT_SIZE )
*   @return     ??????? SS_OK??????????????????
*   @remarks    ?????????????? APP ???????????????????????????????? ????4 ?? ????5 –??????????????????????????????????????????????????????????????????????????????????????????????????????
*               ????????????????????
*
*               ???????“???
*               -# ?????????????????????????????
*               -# ????????????????????????????????????????????????????????
*               -# ??????????????????????????????????????????????????????
*
*   @code
*       {
*           SS_BYTE inbuff[MAX_BUFFER_SIZE] = { 0 };
*           SS_BYTE outbuff[MAX_BUFFER_SIZE] = { 0 };
*           char    *dongle_exe = "dongle.evx"          // ????????????????
*           SS_UINT32 retlen = 0;
*           SS_UINT32 status = 0;
*
*           memcpy(inbuff, "1234567890", 10);
*
*           status = slm_execute_static(slm_handle, dongle_exe, inbuff, 10, outbuff, MAX_BUFFER_SIZE, &retlen);
*           if(status != SS_OK)
*           {
*               //todo do: deal error code
*               return ;
*           }
*           // todo: ???????????????????
*       }
*   @endcode
*   @see        slm_login slm_execute_dynamic slm_snippet_execute
*/
SS_UINT32 SSAPI slm_execute_static(
    IN  SLM_HANDLE_INDEX    slm_handle,
    IN  const char*         exfname,
    IN  SS_BYTE*            inbuf,
    IN  SS_UINT32           insize,
    OUT SS_BYTE*            poutbuf,
    IN  SS_UINT32           outsize,
    OUT SS_UINT32*          pretsize
    );

/*!
*   @brief      ?????????????????????????????????????????????????????????¢???????????????????????????
*   @param[in]  slm_handle  ??????????? #slm_login ???
*   @param[in]  exf_buffer  ???exf ???????????????????? \link D2CAPI \endlink ????? #gen_dynamic_code ???????? D2C????
*   @param[in]  exf_size    ???exf ??????
*   @param[in]  inbuf       ??????????????????????????????
*   @param[in]  insize      ???????????(??????????????????? #SLM_MAX_INPUT_SIZE )
*   @param[out] poutbuf     ?????????????????????????????
*   @param[in]  outsize     ?????????
*   @param[out] pretsize    ???????????(??????????????????? #SLM_MAX_OUTPUT_SIZE )
*   @return     ??????? SS_OK??????????????????
*   @remarks    ?????? #slm_execute_static ????????????????????????????????????????????????????????????????????????????????¤??????????
*               ?? #slm_execute_dynamic ?????????????????????? \link D2CAPI \endlink ??˜??????????????¢?????????????????????????????????????????????????????????????
*   @code
*       {
*           SS_BYTE     exf_buff[MAX_BUFFER_SIZE] = { 0 };       // ???????????????????
*           SS_UINT32   exf_size = 0;                            // ????????????????
*           SS_BYTE     inbuff[MAX_BUFFER_SIZE] = { 0 };
*           SS_BYTE     outbuff[MAX_BUFFER_SIZE] = { 0 };
*           SS_UINT32   retlen = 0;
*           SS_UINT32   status = 0;
*
*           // 1????????????????????
*           // {...}
*
*           memcpy(inbuff, "1234567890", 10);
*
*           status = slm_execute_static(slm_handle, exf_buff, exf_size, inbuff, 10, outbuff, MAX_BUFFER_SIZE, &retlen);
*           if(status != SS_OK)
*           {
*               //todo do: deal error code
*               return ;
*           }
*           // todo: ???????????????????
*       }
*   @endcode
*   @see        slm_login slm_execute_static slm_snippet_execute
*/
SS_UINT32 SSAPI slm_execute_dynamic(
    IN  SLM_HANDLE_INDEX    slm_handle,
    IN  SS_BYTE*            exf_buffer,
    IN  SS_UINT32           exf_size,
    IN  SS_BYTE*            inbuf,
    IN  SS_UINT32           insize,
    OUT SS_BYTE*            poutbuf,
    IN  SS_UINT32           outsize,
    OUT SS_UINT32*          pretsize
    );

/*!
*   @brief      Virbox??????? ?????????????
*   @param[in]  slm_handle   ??????????? #slm_login ???
*   @param[in]  size         ?????????????? #SLM_MEM_MAX_SIZE ??
*   @param[out] mem_id       ??????????id
*   @return     ??????? SS_OK??????????????????
*   @remarks    Virbox??????? ????????????? APP ?????????????????????? Virbox??????? ???????????????????????????????????–???????
*               ?????????????,????????????? ?
*
*               ?–????????? APP ??????????????? Virbox??????? ?????????????????????????????????????????????????????? Virbox??????? ??????????
*               ????????? APP ?? Virbox??????? ?????????????????????? Virbox??????? ???????????
*
*               ???????“???
*               -# ??????????????????????
*               -# ???????????????????
*               -# APP???????????Virbox??????? ??????????????????????????????????????????????????????????????
*
*               ???????????˜?????????????? #SLM_MEM_MAX_SIZE ??˜??????????? mem_id ???????????????????? 256kb??
*
*   @code
*       {
*           SS_UINT32 status = SS_OK;
*           SS_UINT32 mem_index = 0;
*           SS_UINT32 mem_size = 1024;
*           SS_BYTE   data[] = "test data....";
*           SS_BYTE   read[100] = { 0 };
*           SS_UINT32 write_len = 0;
*           SS_UINT32 read_len = 0;
*
*           status = slm_mem_alloc(slm_handle, mem_size, &mem_index);
*           if(status != SS_OK)
*           {
*               //todo do: deal error code
*               return ;
*           }
*           status = slm_mem_write(slm_handle, mem_index, 0, strlen((char *)data), data, &write_len);
*           if(status != SS_OK)
*           {
*               //todo do: deal error code
*               return ;
*           }
*           status = slm_mem_read(slm_handle, mem_index, 0, write_len, read, &read_len);
*           if(status != SS_OK)
*           {
*               //todo do: deal error code
*               return ;
*           }
*           //??????????????????????????
*           //if(data == read)
*           //{
*           //    SUCCESS;
*           //}
*           //else
*           //{
*           //    FAILURE;
*           //}

*           status = slm_mem_free(slm_handle, mem_index);
*       }
*   @endcode
*   @see        slm_mem_free slm_mem_read slm_mem_write
*/
SS_UINT32 SSAPI slm_mem_alloc(
    IN  SLM_HANDLE_INDEX    slm_handle, 
    IN  SS_UINT32           size, 
    OUT SS_UINT32*          mem_id
    );

/*!
*   @brief     ?????????
*   @param[in] slm_handle    ??????????? #slm_login ???
*   @param[in] mem_id        ??????id
*   @return    ??????? SS_OK??????????????????
*   @remarks
*   @code
*       //see slm_mem_alloc
*   @endcode
*   @see       slm_mem_alloc slm_mem_free slm_mem_read slm_mem_write
*/
SS_UINT32 SSAPI slm_mem_free(
    IN  SLM_HANDLE_INDEX    slm_handle, 
    IN  SS_UINT32           mem_id
    );

/*!
*   @brief      Virbox??????? ???????
*   @param[in]  slm_handle    ??????????? #slm_login ???
*   @param[in]  mem_id        ??????id
*   @param[in]  offset        ?????????????
*   @param[in]  len           ?????????????
*   @param[out] readbuff      ??????????????
*   @param[out] readlen       ?????????????
*   @return    ??????? SS_OK??????????????????
*   @remarks
*   @code
*       //see slm_mem_alloc
*   @endcode
*   @see slm_mem_alloc slm_mem_free slm_mem_write
*/
SS_UINT32 SSAPI slm_mem_read(
    IN  SLM_HANDLE_INDEX    slm_handle,
    IN  SS_UINT32           mem_id,
    IN  SS_UINT32           offset,
    IN  SS_UINT32           len,
    IN  SS_BYTE*            readbuff,
    OUT SS_UINT32*          readlen
    );

/*!
*   @brief      Virbox??????? ????????????
*   @param[in]  slm_handle    ??????????? #slm_login ???
*   @param[in]  mem_id        ??????id
*   @param[in]  offset        ??????????
*   @param[in]  len           ??????????????
*   @param[in]  writebuff     ????????????????????????
*   @param[out] numberofbyteswritten ?????????????
*   @return     ??????? SS_OK???????????????????
*   @remarks
*   @code
*       //see slm_mem_alloc
*   @endcode
*   @see slm_mem_alloc slm_mem_free slm_mem_read
*/
SS_UINT32 SSAPI slm_mem_write(
    IN  SLM_HANDLE_INDEX    slm_handle,
    IN  SS_UINT32           mem_id,
    IN  SS_UINT32           offset,
    IN  SS_UINT32           len,
    IN  SS_BYTE*            writebuff,
    OUT SS_UINT32*          numberofbyteswritten
    );

/*!
*   @brief      ?????????????
*   @param[in]  auth     ???????(???????????? NULL ?????
*   @return     SS_UINT32 ??????, ???? SS_OK ????ë????
*   @remarks     ??????? #slm_init ????????????????????????????
*   @see        slm_init
*/
SS_UINT32 SSAPI slm_is_debug(IN void *auth);

/*!
*   @brief      ?????????????????¬??????????
*   @param[in]  slm_handle  ?????????? #slm_login ???
*   @param[in]  cert_type   ??????????? #CERT_TYPE
*   @param[out] cert        ???????
*   @param[in]  cert_size   ?????????
*   @param[out] cert_len    ????????????
*   @return     ??????? SS_OK??????????????????
*   @remarks    ?????????????????????????????
*               ??? cert_type = #CERT_TYPE_DEVICE_CERT???????? #slm_get_device_cert ?????œ?
*               ??????????????????????????
*               ????????????????????????????CA ?????????????????????
*   @see    slm_login slm_get_device_cert
*/
SS_UINT32 SSAPI slm_get_cert(
    IN  SLM_HANDLE_INDEX    slm_handle,
    IN  CERT_TYPE           cert_type,
    OUT SS_BYTE*            cert,
    IN  SS_UINT32           cert_size,
    OUT SS_UINT32*          cert_len
    );

/*!
*   @brief      ??????¬??????????
*   @param[in]  slm_handle  ?????????? #slm_login ???
*   @param[out] device_cert ?????????
*   @param[in]  buff_size   ?????????
*   @param[out] return_size ????????????
*   @return     ??????? SS_OK??????????????????
*   @remarks    ??????¬??????????????????????????????????????
*   @see        slm_login
*/
SS_UINT32 SSAPI slm_get_device_cert(
    IN  SLM_HANDLE_INDEX    slm_handle,
    OUT SS_BYTE*            device_cert,
    IN  SS_UINT32           buff_size,
    OUT SS_UINT32*          return_size
    );

/*!
*   @brief      ???????????????????????
*   @param[in]  slm_handle          ?????????? #slm_login ???
*   @param[in]  verify_data         ?????????????????"SENSELOCK"(9???)?????
*   @param[in]  verify_data_size    ??????????????????? #SLM_VERIFY_DATA_SIZE (41)?????
*   @param[out] signature           ???????????
*   @param[in]  signature_buf_size  ?????????
*   @param[out] signature_size      ?????????
*   @return     ??????? SS_OK??????????????????
*   @remarks    ?????????????????????????????????
*   @code
*       {
*           SS_UINT32       status = SS_OK;
*           SS_BYTE         verify_data[41] = {0};
*           SS_BYTE         my_data[32] = {"verify data..."};
*           const SS_BYTE   header[9] = {"SENSELOCK"};
*           SS_BYTE         signature[2048] = {0};
*           SS_UINT32       signature_size = 0;
*       
*           memcpy(verify_data, header, sizeof(header));
*           memcpy(verify_data + sizeof(header), my_data, sizeof(my_data));
*           
*           status = slm_sign_by_device(slm_handle, verify_data, sizeof(verify_data), signature, sizeof(signature), &signature_size);
*           if(status != SS_OK)
*           {
*               // todo: deal error code
*           }
*       }
*   @endcode
*   @see        slm_login
*/
SS_UINT32 SSAPI slm_sign_by_device(
    IN  SLM_HANDLE_INDEX    slm_handle,
    IN  SS_BYTE*            verify_data,
    IN  SS_UINT32           verify_data_size,
    OUT SS_BYTE*            signature,
    IN  SS_UINT32           signature_buf_size,
    OUT SS_UINT32*          signature_size
    );

/*!
*   @brief         ???????????????????????????????
*   @param[in]     slm_handle  ?????????? #slm_login ???
*   @param[out]    rand        ?????
*   @param[out]    lock_time   ?????
*   @param[in,out] pc_time     PC????????PC???????0?????????
*   @return        ??????? SS_OK ??????????????????
*/
SS_UINT32 SSAPI slm_adjust_time_request(
    IN  SLM_HANDLE_INDEX    slm_handle,
    OUT SS_BYTE             rand[SLM_FIXTIME_RAND_LENGTH],
    OUT SS_UINT32*          lock_time,
    IN OUT SS_UINT32*       pc_time
    );

/*!
*   @brief      ???????
*   @param[in]  slm_handle      ?????????? #slm_login ???
*   @param[in]  led_ctrl        ????????( #ST_LED_CONTROL )
*   @return     ??????? SS_OK ??????????????????
*   @remarks
*   @code
*       {
*           ST_LED_CONTROL led = { 0 };
*           SS_UINT32 status = SS_OK;
*    
*           led.index = 0;         //  0??????LED??1??????LED  
*           led.state = 2;         //  0????????1???????? 2??????? 
*           led.interval = 1000;   //  ????????????
*
*           status = slm_led_control(slm_handle, &led);
*           if(status != SS_OK)
*           {
*               // todo: deal error code
*           }
*       }
*   @endcode
*   @see        slm_login ST_LED_CONTROL
*/
SS_UINT32 SSAPI slm_led_control(
    IN  SLM_HANDLE_INDEX    slm_handle,
    IN  ST_LED_CONTROL*     led_ctrl
    );

/*!
*   @brief      ??? Runtime ?? ?? Virbox??????? ??????.
*   @param[out] api_version  API?????????????
*   @param[out] ss_version   Virbox??????? ???
*   @return     ??????? SS_OK ???????????????????
*/
SS_UINT32 SSAPI slm_get_version(
    OUT SS_UINT32*      api_version, 
    OUT SS_UINT32*      ss_version
    );

/*!
*   @brief     ???API??????????
*   @param[in] buffer API ??????
*/
void SSAPI slm_free(
    IN void*        buffer
    );

/*!
*   @brief      ??????????????D2C?? ?? @link D2CAPI @endlink ?? VirboxLM ?????????? ????
*   @param[in]  d2c_pkg     d2c???????
*   @param[out] error_msg   ???????????????? #slm_free ???
*   @return     ??????? SS_OK ?????????????
*   @remarks:   D2C????????????????????????????????????? json ??????????????????
*               ??????????????????????????????????????????????????? #slm_update_ex ???
*   @code
*     [
*       {"pkg_order":1, "pkg_desc":"package decription.", "status": 0},
*       {"pkg_order":2, "pkg_desc":"package decription.", "status": 0}
*     ]
*   @endcode
*/
SS_UINT32 SSAPI slm_update(
    IN  char*       d2c_pkg, 
    OUT char**      error_msg
    );

/*!
*   @brief      ????????????? VirboxLM ?????????? ????????????????????
*   @param[in]  lock_sn     ???????????????????????,??????????????????????
*   @param[in]  d2c_pkg     d2c????????????
*   @param[out] error_msg   ????????????????????? #slm_free ???
*   @return     ??????? SS_OK ?????????????
*   @remarks: 
*           - ???????????????????????????????
*           - ???????????????????????????? lock_sn????????????????????????????????????????lock_sn ?????????????
*           - ?????????????????????D2C???????????????????˜???????????????????? json ???????? error_msg ??????????????
*           - ???????????????????????????????????????????error_msg ??????????
*   @code
*     error_msg ????
*     [
*       {"pkg_order":1, "pkg_desc":"package decription.", "status": 0},
*       {"pkg_order":2, "pkg_desc":"package decription.", "status": 0}
*     ]
*   @endcode
*   @see    slm_update
*/
SS_UINT32 SSAPI slm_update_ex(
    IN SS_BYTE*     lock_sn, 
    IN char*        d2c_pkg, 
    OUT char**      error_msg
    );

/*!
*   @brief      ????????????????????????????????????????????????????????????
*   @param[in]  lock_sn     ????????????,??????????????
*   @param[in]  inside_file ????????????
*   @return     ??????? SS_OK ?????????????
*   @remarks    Virbox ??????????????????????????????? Virbox??????—????????????????????????????????????
*               ???????????????????????????????? slac_enable.evd??????????????????•????? 256????
*               ????????????????????????????????? h5ses.lib ?? h5ses_lm.lib ?????????????????
*               ???????????????????????????????? #slm_execute_static ?? ??????????????????????????????????????????
*                       ????????????????????????????????????
*               ?????????????? #slm_d2c_update_inside ?????????????????????????????? Virbox?????
*
*               ?????????????????????????????????????????????????????????“????????????????????????????
*   @code
*       {
*           SS_UINT32 status = SS_OK;
*           SS_BYTE   data_buf[1024] = { 0 };
*           SS_UINT32 data_size = 0;
*           char *sn = "9733c80100070205106100030015000c";
*
*           memcpy(data_buf, "1234567890", 10);
*
*           status = slm_execute_static(slm_handle, "test.evx", NULL, 0, data_buf, 10, &data_size);
*           if(status != SS_OK)
*           {
*               // todo: deal error code
*           }
*
*           status = slm_d2c_update_inside(sn, "test.evd");
*           if(status != SS_OK)
*           {
*               // todo: deal error code
*           }
*       }
*   @endcode
*   @see    slm_execute_static
*/
SS_UINT32 SSAPI slm_d2c_update_inside(
    IN char*        lock_sn,
    IN char*        inside_file
    );

/*!
*   @brief       ”??????????
*   @param[out]  device_info    ?????????????????????????? #slm_free ???
*   @return      ??????? SS_OK ?????????????????
*   @remarks     ???????”??????????????????????????????????? #slm_get_info #LOCK_INFO ????????
*   @code
*       // ??? slm_get_license_info ?????????
*   @endcode
*   @see slm_enum_device slm_enum_license_id slm_get_license_info
*/
SS_UINT32 SSAPI slm_enum_device(
    OUT char**  device_info
    );

/*!
*   @brief       ”???????????????????????????
*   @param[in]   format         ??????????? #INFO_FORMAT_TYPE ?????????? #JSON ?? #STRUCT
*   @param[out]  device_info    ?????????????????????????? #slm_free ???
*   @return      ??????? SS_OK ?????????????????
*   @remarks     ???????”??????????????????????????????????? #slm_get_info #LOCK_INFO ????????
*   @code
*       // format = JSON
*           device_info ????? slm_enum_device ??????????œ? ??? slm_get_license_info ?????????
*       // format = STRUCT
            device_info ?????? ST_DEV_INFO_LIST????? slm_get_license_info_ex ???????
*   @endcode
*   @see slm_enum_device slm_enum_license_id slm_get_license_info
*/
SS_UINT32 SSAPI slm_enum_device_ex(
    IN  INFO_FORMAT_TYPE    format,
    OUT void                **device_info
    );

/*!
*   @brief       ”?????????????????ID
*   @param[in]   device_info   ??????????«
*   @param[out]  license_ids   ?????????????ID????#JSON ???????????? #slm_free ??? license_ids
*   @return      ??????? SS_OK ?????????????????
*   @remarks     ?? #slm_enum_device ?????????????????????????????????????????????¬?????????????????????
*   @code
*       // ??? slm_get_license_info ???????
*   @endcode
*   @see slm_enum_device slm_enum_license_id slm_get_license_info
*/
SS_UINT32 SSAPI slm_enum_license_id(
    IN const char   *device_info,
    OUT char        **license_ids
    );

/*!
*   @brief       ”?????????????????ID?????????????????
*   @param[in]   device_info    ???????????
*   @param[in]   format         ??????????? #INFO_FORMAT_TYPE ?????????? #JSON ?? #STRUCT
*   @param[out]  license_ids    ?????????????ID????JSON???????????? #slm_free ??? license_ids
*   @return      ???????SS_OK?????????????????
*   @remarks     ?? #slm_enum_device ?????????????????????????????????????????????¬?????????????????????
*   @code
*       //  ??? slm_get_license_info_ex ???????
*   @endcode
*   @see slm_enum_device slm_enum_license_id slm_get_license_info
*/
SS_UINT32 SSAPI slm_enum_license_id_ex(
    IN  ST_DEV_INFO         *device_info,
    IN  INFO_FORMAT_TYPE    format,
    OUT void                **license_ids
    );

/*!
*   @brief       ????????????????????????
*   @param[in]   device_info    ??????????«
*   @param[in]   license_id     ???????ID
*   @param[out]  license_info   ???????????? #JSON ??? ????? #slm_get_info ?? #LICENSE_INFO
*   @return      ??????? SS_OK ?????????????????
*   @remarks     ???????????? ????ID ????????????????????????
*   @code
*       {
*           char        *lic_id = NULL;
*           char        *dev_desc = NULL;
*           char        *lic_info = NULL;
*           SS_UINT32   status = SS_OK;
*           Json::Reader reader;      // ??????jsoncpp????json????
*           Json::Value  root;
*           Json::Value  lic;
*
*           status = slm_enum_device(&dev_desc);    // ????????????????
*           if ( status == SS_OK && dev_desc != NULL && reader.parse(dev_desc, root))
*           {
*               for (int i = 0; i < root.size(); i++)
*               {
*                   status = slm_enum_license_id(root[i].toStyledString().c_str(), &lic_id);    // ?????˜??????????ID
*                   if (status == SS_OK && lic_id != NULL)
*                   {
*                       printf(lic_id);
*                       printf("\n");
*
*                       if (reader.parse(lic_id, lic))
*                       {
*                           for (int j = 0; j < lic.size(); j++)
*                           {
*                               status = slm_get_license_info(root[i].toStyledString().c_str(), lic[j].asInt(), &lic_info);  // ????????????????
*                               if (lic_info)
*                               {
*                                   printf(lic_info);
*                                   printf("\n");
*                                   slm_free(lic_info);
*                                   lic_info = NULL;
*                               }
*                           }
*                       }
*                       slm_free(lic_id);
*                       lic_id = NULL;
*                   }
*               }
*               slm_free(dev_desc);
*               dev_desc = NULL;
*           }
*       }
*   @endcode
*   @see slm_enum_device slm_enum_license_id slm_get_license_info
*/
SS_UINT32 SSAPI slm_get_license_info(
    IN const char   *device_info,
    IN SS_UINT32    license_id,
    OUT char        **license_info
    );

/*!
*   @brief       ?????????????????????????????????????????
*   @param[in]   device_info    ??????????«
*   @param[in]   format         ??????????? #INFO_FORMAT_TYPE ?????????? #JSON ?? #STRUCT
*   @param[in]   license_id     ???????ID
*   @param[out]  license_info   ???????????? #JSON ??? ????? #slm_get_info ?? #LICENSE_INFO
*   @return      ??????? SS_OK?????????????????
*   @remarks     ????????????????ID????????????????????????
*   @code
*       {
*           void        *dev_desc = NULL;
*           SS_UINT32   dev_count = 0;
*           void        *lic_desc = NULL;
*           void         *lic_info = NULL;
*           int         status = SS_OK;
*           
*           status = slm_enum_device_ex(STRUCT, &dev_desc);
*           
*           if (status == SS_OK && dev_desc != NULL)
*           {
*               ST_DEV_INFO_LIST *dl = (ST_DEV_INFO_LIST*)dev_desc;
*               //printf("DEV LIST COUNT:%d\n", dl->count);
*               for (int i = 0; i != dl->count; ++i)
*               {
*                   status = slm_enum_license_id_ex(&dl->info[i].dev_info, STRUCT, &lic_desc);
*                   if (status == SS_OK && lic_desc != NULL)
*                   {
*                       ST_LICENSE_IDS  *lic = (ST_LICENSE_IDS*)lic_desc;
*                       //printf("License Count : %d\n", lic->count);
*                       for (int j = 0; j != lic->count; ++j)
*                       {
*                           status = slm_get_license_info_ex(&dl->info[i].dev_info, lic->lic_ids[j], STRUCT, &lic_info);
*                           if (status == SS_OK && lic_info != NULL)
*                           {
*                               //printf("LicenseID = %d; first use time = %d\n", ((ST_SLM_LICENSE_INFO*)lic_info)->lic_id, ((ST_SLM_LICENSE_INFO*)lic_info)->first_use_time);
*                               slm_free(lic_info);
*                               lic_info = NULL;
*                           }
*                       }
*                       slm_free(lic_desc);
*                       lic_desc = NULL;
*                   }
*               }
*               slm_free(dev_desc);
*               dev_desc = NULL;
*           }
*       }
*   @endcode
*   @see slm_enum_device slm_enum_license_id slm_get_license_info
*/
SS_UINT32 SSAPI slm_get_license_info_ex(
    IN  ST_DEV_INFO          *device_info,
    IN  SS_UINT32           license_id,
    IN  INFO_FORMAT_TYPE    format,
    OUT void                **license_info
    );

/*!
*   @brief     ??????
*   @param[in] slm_handle     ?????????? #slm_login ???
*   @param[in] module_id      ???ID????????1 ~ 64??
*   @return    ????????? SS_OK ??????????? SS_ERROR_LICENSE_MODULE_NOT_EXISTS , ????????????????
*/
SS_UINT32 SSAPI slm_check_module(IN SLM_HANDLE_INDEX slm_handle, IN SS_UINT32 module_id);

/*!
*   @brief      ????????????????????????
*   @param[in]  slm_handle      ??????
*   @param[in]  snippet_code    ???????
*   @param[in]  code_size       ?????????
*   @param[in]  input           ????????
*   @param[in]  input_size      ???????????
*   @param[out] output          ?????????
*   @param[in]  outbuf_size     ?????????????
*   @param[out] output_size     ??????????
*   @return     ???????SS_OK??????????????????
*   @see        slm_login slm_execute_static slm_execute_dynamic
*/
SS_UINT32 SSAPI slm_snippet_execute(
    IN  SLM_HANDLE_INDEX    slm_handle,
    IN  SS_BYTE*            snippet_code,
    IN  SS_UINT32           code_size,
    IN  SS_BYTE*            input, 
    IN  SS_UINT32           input_size, 
    OUT SS_BYTE*            output, 
    IN  SS_UINT32           outbuf_size, 
    OUT SS_UINT32*          output_size
    );

/*!
*   @brief      ??? Runtime ???????????ID
*   @param[out] developer_id          ?????????ID????????????
*   @return     ??????? SS_OK ?????????????????
*   @remarks    ??? developer_id ?????????? #SLM_DEVELOPER_ID_SIZE ???????????????????
*/
SS_UINT32 SSAPI slm_get_developer_id(OUT SS_BYTE developer_id[SLM_DEVELOPER_ID_SIZE]);

/*!
*  @brief      ??????¬???????????????????????????
*  @param[in]  slm_handle       ?????????? #slm_login ???
*  @param[in]  sign_data        ???????????????16???????64????
*  @param[in]  sign_length      ?????????????
*  @param[out] signature        ????????????
*  @param[in]  max_buf_size     ???????????????
*  @param[out] signature_length ????????????
*  @return     ??????? SS_OK ?????????????
*  @remarks    ?????????????????????????????????
*  @see        slm_license_verify 
*/
SS_UINT32 SSAPI slm_license_sign(
    IN  SLM_HANDLE_INDEX   slm_handle,
    IN  SS_BYTE           *sign_data,
    IN  SS_UINT32          sign_length,
    OUT SS_BYTE           *signature,
    IN  SS_UINT32          max_buf_size,
    OUT SS_UINT32         *signature_length
    );

/*!
*  @brief      ?????????????????????????????????????
*  @param[in]  sign_data        ??????????????? 16??????? 64????
*  @param[in]  sign_length      ?????????????
*  @param[in]  signature        ??????????
*  @param[in]  signature_length ??????????
*  @param[out] sign_info        ????????????json????????????????????? #slm_free ???
*  @return     ?????????? SS_OK ?????????????
*  @remarks   -??????????????? #slm_free ??? sign_info
*             -?????????????¬????
*  @code 
   //json????
   {
       "type":2,                                   // 2???????
       "developer_id":0000000000000000,            // ??????ID
       "license_id":0,                             // ????ID
       "guid":xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,    // ?–?guid?????????????
       "sn":00000000000000000000000000000000,      // ????????????????
       "rand":0,                                   // ?????
   }
   @endcode
*  @see  slm_license_sign slm_free
*/
SS_UINT32 SSAPI slm_license_verify(
    IN  SS_BYTE      *sign_data,
    IN  SS_UINT32       sign_length,
    IN  SS_BYTE      *signature,
    IN  SS_UINT32     signature_length,
    OUT char        **sign_info
    );

/*!
*   @brief      ??????????“??????
*   @param[in]  error_code  ????? API ?????????????????
*   @param[in]  language_id ??????????????????? #LANGUAGE_CHINESE_ASCII ??
*   @return     ????????????????????????????????? #slm_free ???????????????? NULL 
*   @remarks    ????????????????????????????????? #slm_free ???
*/
const SS_CHAR * SSAPI slm_error_format(
    IN SS_UINT32    error_code,
    IN SS_UINT32    language_id
    );

/*!
*   @brief      ??????????????? #slm_init ???
*   @see        slm_init
*   @remarks    #slm_cleanup ????????????????????????????????????????????????????–?????????
*               ????????????????????????? Runtime API ???????????????????????????? ?
*               ???????????????????????API???? #slm_init ?????????? ?
*/
SS_UINT32 SSAPI slm_cleanup(void);

/*!
*   @brief      ?????????
*   @param[in]  config    ???•????? #JSON ??
*               1. #slm_login ?????????????????¬?????????????????????????? URL ??????¢??? #SLM_MAX_CLOUD_SERVER_LENGTH ???????
*                           {"urls": {"cloud_runtime_url": "http://rt.senseyun.com","slock_url": "http://sl.senseyun.com","dl_url": "http://ll.senseyun.com"}}
*   @return     ??????? SS_OK ?????????????????
*   @remarks    ???????????????????????????????????????????????
*/
SS_UINT32 SSAPI slm_extensions_config(IN const char *config);

#ifdef __cplusplus
};
#endif //__cplusplus

/**
*   @}
*/


#endif // #ifndef __SS_LM_RUMTIME_H__

